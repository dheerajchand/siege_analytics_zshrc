#!/usr/bin/env zsh
# =====================================================
# 3-TIER ZSH CONFIGURATION - SYSTEMATIC PRODUCTION
# =====================================================
#
# Design: Evidence-based architecture from hostile testing
# Principle: Dependency-first loading with real functionality verification
# Version: Systematic repair based on actual usage analysis
#
# TIER 1: Core (always loaded)
# TIER 2: Modules (on-demand with dependency resolution)
# TIER 3: Services (background optimization)
# =====================================================

export ZSH_CONFIG_DIR="$HOME/.config/zsh"

# =====================================================
# TIER 1: CORE FOUNDATION (CRITICAL - MUST NOT FAIL)
# =====================================================

echo "üîß TIER 1: Loading core foundation..."

# 1.1 Load centralized variables FIRST
if [[ -f "$ZSH_CONFIG_DIR/config/variables.zsh" ]]; then
    source "$ZSH_CONFIG_DIR/config/variables.zsh"
    echo "  ‚úÖ Variables loaded"
else
    echo "  ‚ùå CRITICAL: Variables not found"
    exit 1
fi

# 1.2 Load core functions BEFORE modules (DEPENDENCY REQUIREMENT)
if [[ -f "$ZSH_CONFIG_DIR/config/core.zsh" ]]; then
    source "$ZSH_CONFIG_DIR/config/core.zsh"
    echo "  ‚úÖ Core functions loaded"

    # Verify critical dependencies for modules
    if ! typeset -f path_add >/dev/null; then
        echo "  ‚ùå CRITICAL: path_add function missing (required by Spark module)"
        exit 1
    fi
else
    echo "  ‚ùå CRITICAL: Core functions not found"
    exit 1
fi

# 1.3 Oh My Zsh setup
export ZSH="$HOME/.config/zsh/oh-my-zsh"
ZSH_THEME="powerlevel10k/powerlevel10k"
plugins=(git)

if [[ -f "$ZSH/oh-my-zsh.sh" ]]; then
    source $ZSH/oh-my-zsh.sh
    echo "  ‚úÖ Oh My Zsh loaded"
fi

# 1.4 Load P10K config
[[ ! -f ~/.p10k.zsh ]] || source ~/.p10k.zsh

# 1.5 Basic aliases (always available)
alias ll='ls -alF'
alias la='ls -A'
alias l='ls -CF'

# 1.6 Basic functions (always available)
mkcd() { mkdir -p "$1" && cd "$1"; }
command_exists() { command -v "$1" >/dev/null 2>&1; }

echo "‚úÖ TIER 1: Core foundation ready"

# =====================================================
# TIER 2: MODULE LOADING SYSTEM WITH DEPENDENCY RESOLUTION
# =====================================================

echo "üîß TIER 2: Initializing module system..."

# Initialize module tracking
export LOADED_MODULES=""

# Enhanced module loading with dependency checking and real functionality verification
load_module() {
    local module="$1"
    local module_path="$ZSH_CONFIG_DIR/modules/$module.module.zsh"

    if [[ -z "$module" ]]; then
        echo "‚ùå Error: No module name provided"
        echo "üìã Usage: load_module <module_name>"
        echo "üìã Available modules:"
        ls "$ZSH_CONFIG_DIR/modules"/*.module.zsh 2>/dev/null | xargs -n1 basename | sed 's/.module.zsh$//' | sed 's/^/  /'
        return 1
    fi

    # Pre-check dependencies
    case "$module" in
        spark)
            if ! typeset -f path_add >/dev/null; then
                echo "‚ùå Error: $module requires core.zsh (path_add function missing)"
                echo "üîß Fix: Ensure core.zsh is loaded before loading $module"
                return 1
            fi
            ;;
        database)
            if ! command -v _report_missing_dependency >/dev/null; then
                echo "‚ùå Error: $module requires utils module for error reporting"
                echo "üîß Fix: Load utils module first"
                return 1
            fi
            ;;
    esac

    if [[ -f "$module_path" ]]; then
        echo "üì¶ Loading $module module..."

        # Load with error capture
        if source "$module_path" 2>/dev/null; then
            # Verify module provides expected functionality
            local verification_result
            case "$module" in
                utils)
                    if command -v backup >/dev/null; then
                        verification_result="‚úÖ Backup system available"
                    else
                        verification_result="‚ö†Ô∏è  Backup system not available"
                    fi
                    ;;
                python)
                    if python3 --version >/dev/null 2>&1; then
                        verification_result="‚úÖ Python $(python3 --version | cut -d' ' -f2) functional"
                    else
                        verification_result="‚ö†Ô∏è  Python not functional"
                    fi
                    ;;
                docker)
                    if docker version >/dev/null 2>&1; then
                        verification_result="‚úÖ Docker $(docker version --format '{{.Client.Version}}') functional"
                    else
                        verification_result="‚ö†Ô∏è  Docker daemon not available"
                    fi
                    ;;
                spark)
                    if command -v spark-submit >/dev/null 2>&1; then
                        verification_result="‚úÖ Spark functional"
                    else
                        verification_result="‚ö†Ô∏è  Spark not available"
                    fi
                    ;;
                *)
                    verification_result="‚úÖ Module loaded"
                    ;;
            esac

            # Update module tracking
            if [[ -z "$LOADED_MODULES" ]]; then
                export LOADED_MODULES="$module"
            else
                export LOADED_MODULES="$LOADED_MODULES $module"
            fi

            echo "‚úÖ Module $module loaded successfully!"
            echo "üîç Verification: $verification_result"
            echo "üìä Total modules loaded: $(echo $LOADED_MODULES | wc -w | tr -d ' ')"
            return 0
        else
            echo "‚ùå Error: Failed to load $module - source error or missing dependencies"
            return 1
        fi
    else
        echo "‚ùå Module not found: $module"
        echo "üìã Available modules:"
        ls "$ZSH_CONFIG_DIR/modules"/*.module.zsh 2>/dev/null | xargs -n1 basename | sed 's/.module.zsh$//' | sed 's/^/  /'
        return 1
    fi
}

# Quick module aliases
alias load-python='load_module python'
alias load-utils='load_module utils'
alias load-docker='load_module docker'
alias load-spark='load_module spark'
alias load-database='load_module database'

echo "‚úÖ TIER 2: Module system ready"

# =====================================================
# TIER 2: ESSENTIAL MODULE AUTO-LOADING (CONTEXT-AWARE)
# =====================================================

echo "üîß TIER 2: Loading essential modules..."

# Detect Claude Code environment
claude_parent_process=$(ps -p $PPID -o comm= 2>/dev/null || echo "")
if [[ "$claude_parent_process" == "claude" ]] || [[ -n "$CLAUDE_CODE_SESSION" ]]; then
    echo "ü§ñ Claude Code environment detected"

    # Load essential modules for development
    echo "üì¶ Loading essential modules for Claude Code..."

    # Load utils first (provides backup system)
    if load_module utils; then
        echo "  ‚úÖ Utils module ready for Claude Code"
    else
        echo "  ‚ö†Ô∏è  Utils module failed - backup system may not be available"
    fi

    # Load python for development work
    if load_module python; then
        echo "  ‚úÖ Python module ready for Claude Code"
    else
        echo "  ‚ö†Ô∏è  Python module failed - Python environments may not be available"
    fi

    echo "üì¶ Claude Code essential modules loaded"
else
    echo "üñ•Ô∏è  Regular terminal environment detected"
    echo "üí° Use load_module commands to load features on-demand"
fi

# =====================================================
# MODE DETECTION SYSTEM
# =====================================================

detect_zsh_mode() {
    # Manual mode override (highest priority)
    if [[ -n "${ZSH_MODE:-}" ]]; then
        echo "$ZSH_MODE"
        return 0
    fi

    # Check parent process for IDE context
    local parent_process=""
    if command -v ps >/dev/null 2>&1; then
        parent_process=$(ps -p $PPID -o comm= 2>/dev/null || echo "")
    fi

    # JetBrains IDEs
    if [[ -n "$JETBRAINS_IDE" || -n "$PYCHARM_HOSTED" || -n "$DATASPELL_IDE" || "$TERM_PROGRAM" == "JetBrains"* ]]; then
        echo "staggered"
        return 0
    fi

    # VSCode and Cursor
    if [[ -n "$VSCODE_PID" || "$TERM_PROGRAM" == "vscode" || -n "$VSCODE_INJECTION" || "$TERM_PROGRAM" == "Cursor" ]]; then
        echo "staggered"
        return 0
    fi

    # Check parent process patterns
    if [[ "$parent_process" == *"code"* || "$parent_process" == *"cursor"* || "$parent_process" == *"pycharm"* ]]; then
        echo "staggered"
        return 0
    fi

    # Default to staggered mode
    echo "staggered"
}

# =====================================================
# SYSTEM MANAGEMENT FUNCTIONS
# =====================================================

startup_status() {
    local path_length=${#PATH}
    local loaded_count=0
    local available_modules=0

    # Count actually loaded modules
    if [[ -n "$LOADED_MODULES" ]]; then
        loaded_count=$(echo $LOADED_MODULES | wc -w | tr -d ' ')
    fi

    # Count available modules
    if [[ -d "$ZSH_CONFIG_DIR/modules" ]]; then
        available_modules=$(ls "$ZSH_CONFIG_DIR/modules"/*.module.zsh 2>/dev/null | wc -l | tr -d ' ')
    fi

    # System health assessment
    local system_status="Production Ready"
    if [[ $loaded_count -eq 0 ]]; then
        system_status="‚ö†Ô∏è  No modules loaded"
    elif [[ ! -f "$ZSH_CONFIG_DIR/config/core.zsh" ]]; then
        system_status="‚ö†Ô∏è  Core functions missing"
    fi

    echo "üöÄ 3-Tier ZSH System - $system_status"
    echo "======================================"
    echo "üìä Status: PATH=$path_length chars, $loaded_count/$available_modules modules loaded"
    echo "üîß Mode: $(detect_zsh_mode)"
    echo "üì¶ Loaded modules: ${LOADED_MODULES:-none}"
    echo ""
    echo "üí° Available commands:"
    echo "  startup_status     # Show this status"
    echo "  load_module <name> # Load specific module"
    echo "  modules            # Show available modules"
}

show_loaded_modules() {
    echo "üìä Module Status"
    echo "==============="
    echo "üöÄ Core: Always loaded (variables, core functions, Oh-My-Zsh)"

    if [[ -n "$LOADED_MODULES" ]]; then
        echo "üì¶ Loaded modules: $LOADED_MODULES"
    else
        echo "üì¶ Loaded modules: None"
    fi

    echo ""
    echo "üìã Available modules:"
    ls "$ZSH_CONFIG_DIR/modules"/*.module.zsh 2>/dev/null | xargs -n1 basename | sed 's/.module.zsh$//' | sed 's/^/  /'
    echo ""
    echo "üí° Use 'load_module <name>' to load modules on-demand"
}

alias modules='show_loaded_modules'

zshreload() {
    echo "üîÑ Reloading ZSH configuration..."
    source ~/.zshrc
    echo "‚úÖ Configuration reloaded successfully"
}

zshreboot() {
    echo "üîÑ Restarting ZSH shell..."
    exec zsh -i
}

# =====================================================
# TIER 3: BACKGROUND SERVICES (OPTIONAL)
# =====================================================

# Note: Background services are implemented separately in zsh-system
# This avoids startup delays and potential hanging issues

echo "‚úÖ TIER 3: Background services available via zsh-system"

# =====================================================
# STARTUP COMPLETION
# =====================================================

echo ""
echo "üéâ 3-Tier ZSH System - Systematic Production Ready"
echo "=================================================="

# Show startup status
startup_status

export SYSTEMATIC_ZSHRC_LOADED=true

# =====================================================
# EXTERNAL PATH MODIFICATIONS (KEEP AT END)
# =====================================================

### MANAGED BY RANCHER DESKTOP START (DO NOT EDIT)
export PATH="/Users/dheerajchand/.rd/bin:$PATH"
### MANAGED BY RANCHER DESKTOP END (DO NOT EDIT)